{"note":"Don't delete this file! It's used internally to help with page regeneration.","body":"## what does it do?!\r\n   \r\nCameraDetection is a simple library that handles all of the hassle about getting a WORKIGN Camera object in flash. This library also solves the age old problem of getting permission from the user! \r\n\r\nhere is what CameraDetection can tell you:\r\n* when the media permission dialog opens AND closes!\r\n* if there are no cameras installed\r\n* if the user granted or denied permission\r\n* if the user had 'remembered' their decision from last time\r\n* if there were cameras to use, but none of them worked\r\n\r\n    \r\n***\r\n\r\n***disclaimer:*** *although i am confident about the code i have written, i cannot guarantee it is bug free.*\r\n\r\n***\r\n\r\n<br/><br/>\r\n## how to use\r\n\r\nbelow are all the necessary steps to get all the info you need from CameraDetection.\r\nit should all be very straight forward.\r\n\r\n\r\n    import ktu.events.CameraDetectionEvent;\r\n    import ktu.events.MediaPermissionsEvent;\r\n    import ktu.media.CameraDetection;\r\n    import ktu.media.CameraDetectionResult;\r\n    import ktu.media.MediaPermissionsResult;\r\n\r\n    var cd:CameraDetection = new CameraDetection(stage);\r\n    cd.addEventListener (CameraDetectionEvent.RESOLVE, onResolve);\r\n    cd.addEventListener(MediaPermissionsEvent.DIALOG_STATUS, onDialogStatus);\r\n    cd.begin();\r\n\r\n    function onDialogStatus (e:MediaPermissionsEvent):void {\r\n        switch (e.code) {\r\n            case MediaPermissionsResult.DIALOG_OPEN:\r\n                trace(\"dialog opened\");\r\n                break;\r\n            case MediaPermmissionsResult.DIALOG_CLOSED:\r\n                trace(\"dialog closed\");\r\n                break;\r\n        }\r\n    }\r\n    function onResolve(e:CameraDetectionEvent):void {\r\n        switch (e.code) {\r\n            case CameraDetectionResult.SUCCESS :\r\n                trace(\"got a camera!!! - \" + e.camera.name);\r\n                break;\r\n            case CameraDetectionResult.NO_PERMISSION :\r\n                trace(\"Camera access denied\");\r\n                break;\r\n            case CameraDetectionResult.NO_CAMERAS :\r\n                trace(\"There are no cameras connected to the computer\");\r\n                break;\r\n            case CameraDetectionResult.NO_SUCCESS:\r\n                trace(\"there was at least one camera, but none worked!!\");\r\n                break;\r\n        }\r\n    }\r\n\r\n<br/><br/>    \r\n    \r\n## show me\r\n\r\nlet me show you how this works and what you can get from it\r\n\r\n***\r\n\r\nby clicking on the link you AGREE to allow me to capture anonymous data about the camera detection process: CameraDetection Example (coming soon!)\r\n\r\n***\r\n\r\n<br/><br/>\r\n \r\n\r\n    \r\n## why & how\r\n\r\nthere are a few important points to address with why i made this library and how it works. first, if you have worked with Camera before, getting permission to use the device is a pain. no one likes the settings dialog in the flash player. well, that issue has been solved. next, there is the problem of Camera.getCamera() returning a valid object but the camera doesn't actually work. and lastly, there are general problems with certain operating systems and drivers.\r\n\r\n<br/>\r\n### MediaPermissions\r\n\r\nto start, [this bug](https://bugs.adobe.com/jira/browse/FP-41) in adobe's jira which started in 2008 is still open, and untouched. and it was changed from a bug to a feature request. this bug is part of what makes working with media devices a nightmare. \r\n\r\nbut guess what! i believe i have solved this problem, lets look at how to use MediaPermissions:\r\n\r\n\r\n\r\n\timport ktu.events.MediaPermissionsEvent;\r\n\timport ktu.media.MediaPermissions;\r\n\timport ktu.media.MediaPermissionsResult;\r\n\r\n\tvar mp:MediaPermissions = new MediaPermissions(stage);\r\n\tmp.mode = MediaPermissions.PRIVACY_DIALOG;\r\n\tmp.addEventListener (MediaPermissionsEvent.DIALOG_STATUS, onDialogStatus);\r\n\tmp.addEventListener (MediaPermissionsEvent.RESOLVE, onPermissionsResolve);\r\n\tmp.getPermission(Camera);\r\n\r\n\tfunction onDialogStatus (e:MediaPermissionsEvent):void {\r\n\t\tif (e.code == MediaPermissionsResult.DIALOG_OPEN)\r\n\t\t\ttrace (\"dialog opened\");\r\n\t\telse if (e.code == MediaPermissionsResult.DIALOG_CLOSED)\r\n\t\t\ttrace (\"dialog closed\");\r\n\t}\r\n\r\n\tfunction onPermissionsResolve (e:MediaPermissionsEvent):void {\r\n\t\tswitch (e.code) {\r\n\t\t\tcase MediaPermissionsResult.GRANTED :\r\n\t\t\t\ttrace (\"permissions granted\");\r\n\t\t\t\tbreak;\r\n\t\t\tcase MediaPermissionsResult.DENIED:\r\n\t\t\t\ttrace(\"permissions denied\");\r\n\t\t\t\tbreak;\r\n\t\t\tcase MediaPermissionsResult.NO_DEVICE:\r\n\t\t\t\ttrace(\"there was no device to use!\");\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n**mode** lets you choose whether to display the quick access dialog box, or the privacy dialog box.\r\n\r\n**timerDelay** lets you choose how often it checks to see if the dialog has closed\r\n\r\n**stage** it NEEDS a reference to the stage for it to work, pass in through constructor, or by public var\r\n\r\n\r\n<br/>\r\n### how it works\r\n\r\nthanks to Philippe Piernot with his workaround, this object can actually work. his workaround makes an attempt to draw the stage into a BitmapData object. if trying to draw the stage cause an error, then the dialog is still open.\r\n\r\nthere are a few key components to what MediaPermissions needs to do in order to compensate for the 'feature request' we have been asking for since 2008.\r\n\r\nfirst, as documentation would suggest, listening to the StatusEvent.STATUS on a Media device handles most cases. it breaks down when the user selects the 'remember' checkbox. \r\n\r\nif you 'remember' your decision and then use the quick access dialog. NOTHING HAPPENS! no StatusEvent is fired. you get no information to tell you that the dialog even showed up!\r\n\r\nif you use the privacy dialog, the status event will fire, but the user could choose to never close the dialog! and, the user could not select and option, but simply click close, and in that case, no event is fired natively.\r\n\r\nso, using a combination of the status event, and this workaround on a timer, MediaPermissions can simply handle all of the possibilities.\r\n\r\nif you desire to know exactly how it works, just look in the source! it is not all that complicated!\r\n\r\n\r\n<br/>\r\n### CameraChecker\r\n\r\nthis class is just an abstraction that puts all the code of checking if a Camera is responding in one place.\r\n\r\nif you were to use this class on your own it might look something like this:\r\n    \r\n    import ktu.media.CameraChecker;\r\n    \r\n    var cameraChecker:CameraChecker = new CameraChecker();\r\n    cameraChecker.timerDelay = 50;\r\n    cameraChecker.repeatCount = 100; \r\n    cameraChecker.blackoutDelay = 800;\r\n    cameraChecker.addEventListener(CameraDetectionEvent.RESOLVE, onCCheckerResolve);\r\n    \r\n    var camera:Camera = Camera.getCamera();\r\n    cameraChecker.check(camera);\r\n\r\n    function onCCheckerResolve(e:CameraDetectionEvent.RESOLVE):void {\r\n        if (e.code == CameraDetectionResult.SUCCESS) {\r\n            trace(\"camera is good to go\");\r\n        } else if (e.code == CameraDetectionResult.NO_SUCCESS) {\r\n            trace (\"camera is bad\");\r\n        }\r\n    }\r\n\r\n\r\n**timerDelay** and **repeatCount** properties allow you to specify how long to check the Camera. these directly relate to the Timer used in the class\r\n\r\n**blackoutDelay**: this value is an int in milliseconds that the CameraChecker should wait, before dispatching that the camera is 'good'. this is only applied if the camera is good, otherwise it is ignored. \r\n\r\npersonally, i have always hated that when you first start using a camera, that it fades from black to actual imagery. watching that happens just makes me cringe. so, this value is designed to let you attempt to hide that from the user. \r\n\r\n<br/>\r\n## Cameras Suck\r\nCameraChecker has to deal with the shitty limitations of the Camera implementation.\r\n\r\nfirst, the most common problem that occurs when using Camera in flash is that you will get a valid object from Camera.getCamera() but it actually won't work for you.\r\n\r\n<br/>\r\n### causes\r\n\r\n1. if the camera is already in use. This is most common if you have skype running on your computer. you don't even have to be using the camera at that moment, but the last i checked, if skype is open, it is stealing your camera.\r\n\r\n2. mac laptops have/used to have multiple cameras listed even though they were not connected. this frequently showed up as DVI camera and something else (sorry for the poor memory). if for some reason one of these 'disconnected' cameras was chosen as the default, then you will experience your problem.\r\n\r\n3. the google chat/video adapter have caused problems in the past. simply having installed it caused many issues for people for a while (this may have started ~2011?) since you never know which OS or player version you'll get this may still be an issue \r\n\r\n\r\n<br/>\r\n### why this problem sucks\r\n\r\ndetermining if a Camera is actually working is a pain. the best option we have is to monitor the Camera's activity and fps to see if it is working.\r\n\r\nwhat you should expect\r\n\r\nto determine the behavior of a working camera, i use a timer to check on the fps and activity levels of the Camera. this is a common result: (this timer is set at 100ms)\r\n\r\n\tfps:0   activity:-1\r\n\t ...  x20  ...\r\n\tfps:0   activity:100\r\n\tfps:0   activity:100\r\n\tfps:8.1 activity:5\r\n\tfps:8.5 activity:46\r\n\tfps:8.2 activity:3\r\n\tfps:8.4 activity:3\r\n\r\nso, the camera appears unresponsive for 2.1 whole seconds!!! what!?!?!? I know. but then it finally kicks in. this is common behavior even though I am testing this on a 6core 3.3GHz machine with little running. my library keeps checking the camera waiting for these activity and fps levels to change.\r\n\r\nwhat you get when it doesn't work\r\n\r\ncan you guess what happens when the camera doesn't work? you guessed it!\r\n\r\nyou get this non-stop, forever\r\n\r\n\tfps:0 activity:-1\r\n\tfps:0 activity:-1\r\n\tfps:0 activity:-1\r\n\r\nso my code will check a camera by default for 3 whole seconds, waiting for some activity, and then quit. this is the bad part, maybe all the hardware sucks and the cpu is already overloaded and this makes it take longer than 3 seconds to get a response? woe is us actionscript guys. \r\n\r\n\r\n<br/><br/>\r\n## conclusion\r\n\r\nhopefully my library is useful. if you notice something wrong, please tell me!\r\n\r\ni have despised this problem for years, and it frustrates me more knowing that adobe continues to ignore this. one of the few things flash still has over html is utilizing the webcam. \r\n","google":"","name":"Cameradetection","tagline":"as3 camera detection so you don't have to"}